<template>
    <view class="wx-content-info" wx:if="{{ imageSrc }}">
        <view wx:if="{{ isShowImg }}" class="wx-corpper" style="width:{{cropperInitW}}rpx;height:{{cropperInitH}}rpx;">
            <view class="wx-corpper-content" style="width:{{cropperW}}rpx;height:{{cropperH}}rpx;left:{{cropperL}}rpx;top:{{cropperT}}rpx">
                <image src="{{ imageSrc }}" style="width:{{cropperW}}rpx;height:{{cropperH}}rpx"></image>
                <view class="wx-corpper-crop-box" bindtouchstart="contentStartMove" bindtouchmove="contentMoveing" style="width:{{cutW}}rpx;height:{{cutH}}rpx;left:{{cutL}}rpx;top:{{cutT}}rpx">
                    <view class="wx-cropper-view-box">
                        <view class="wx-cropper-dashed-h"></view>
                        <view class="wx-cropper-dashed-v"></view>
                        <view class="wx-cropper-line-t" data-drag="top" catchtouchstart="dragStart" catchtouchmove="dragMove"></view>
                        <view class="wx-cropper-line-r" data-drag="right" catchtouchstart="dragStart" catchtouchmove="dragMove"></view>
                        <view class="wx-cropper-line-b" data-drag="bottom" catchtouchstart="dragStart" catchtouchmove="dragMove"></view>
                        <view class="wx-cropper-line-l" data-drag="left" catchtouchstart="dragStart" catchtouchmove="dragMove"></view>
                        <view class="wx-cropper-point point-t" data-drag="top" catchtouchstart="dragStart" catchtouchmove="dragMove"></view>
                        <view class="wx-cropper-point point-tr" data-drag="topTight"></view>
                        <view class="wx-cropper-point point-r" data-drag="right" catchtouchstart="dragStart" catchtouchmove="dragMove"></view>
                        <view class="wx-cropper-point point-rb" data-drag="rightBottom" catchtouchstart="dragStart" catchtouchmove="dragMove"></view>
                        <view class="wx-cropper-point point-b" data-drag="bottom" catchtouchstart="dragStart" catchtouchmove="dragMove"></view>
                        <view class="wx-cropper-point point-bl" data-drag="bottomLeft"></view>
                        <view class="wx-cropper-point point-l" data-drag="left" catchtouchstart="dragStart" catchtouchmove="dragMove"></view>
                        <view class="wx-cropper-point point-lt" data-drag="leftTop"></view>
                    </view>
                </view>
                <view class="crop-mask" style="border-top-width:{{cutT}}rpx;border-right-width:{{cropperW-cutL-cutW}}rpx;border-bottom-width:{{cropperH-cutT-cutH}}rpx;border-left-width:{{cutL}}rpx;"></view>
            </view>
        </view>
        <canvas canvas-id="myCanvas" style="position:absolute;border: 1px solid red; width:{{qualityWidth}}px;height:{{qualityWidth/innerAspectRadio}}px;top:-9999px;right:-9999px;"></canvas>
        <view class="options">
            <view class="option-item restore">还原</view>
            <view class="option-item rotate" @tap="rotateImage">旋转</view>
            <view class="option-item cancel">取消</view>
            <view class="option-item crop" @tap="getImageInfo">裁剪</view>
        </view>
        <view @tap="getImage" style="color:#FFF;">选择图片</view>
  </view>
</template>

<script>
import wepy from 'wepy';

// pages/wx-cropper/index.js
// 手机的宽度
const windowWRPX = 750;
// 拖动时候的 pageX
let pageX = 0;
// 拖动时候的 pageY
let pageY = 0;

const { pixelRatio } = wx.getSystemInfoSync();

// 调整大小时候的 pageX
let sizeConfPageX = 0;
// 调整大小时候的 pageY
let sizeConfPageY = 0;

let initDragCutW = 0;
let initDragCutL = 0;
let initDragCutH = 0;
let initDragCutT = 0;
const qualityWidth = 100;
let innerAspectRadio = 1;
// 移动时 手势位移与 实际元素位移的比
const dragScaleP = 2;
const ctx = wx.createCanvasContext('myCanvas');

export default class Cropper extends wepy.component {
    props = {
        imageSrc: {
            type: String,
            default: '',
        },
    }
    data = {
        isShowImg: false,
        // 初始化的宽高
        cropperInitW: windowWRPX,
        cropperInitH: windowWRPX,
        // 动态的宽高
        cropperW: windowWRPX,
        cropperH: windowWRPX,
        // 动态的left top值
        cropperL: 0,
        cropperT: 0,

        // 图片缩放值
        scaleP: 0,
        imageW: 0,
        imageH: 0,

        // 裁剪框 宽高
        cutW: 0,
        cutH: 0,
        cutL: 0,
        cutT: 0,
        qualityWidth: qualityWidth,
        innerAspectRadio: innerAspectRadio,

        testRange: [['1111', 'k12j'], ['jwiefj', 'wijfeiewj']],
    };

    events = {
        'crop-loadImage'() {
            console.log('load image');
            const that = this;
            wx.showLoading({
                title: '图片加载中...',
            });

            ctx.drawImage(
                that.imageSrc,
                0,
                0,
                qualityWidth,
                qualityWidth / innerAspectRadio,
            );
            ctx.draw();

            wx.getImageInfo({
                src: that.imageSrc,
                success(res) {
                    innerAspectRadio = res.width / res.height;
                    // 根据图片的宽高显示不同的效果   保证图片可以正常显示
                    if (innerAspectRadio >= 1) {
                        that.cropperW = windowWRPX;
                        that.cropperH = windowWRPX / innerAspectRadio;
                        that.cropperL = Math.ceil((windowWRPX - windowWRPX) / 2);
                        that.cropperT = Math.ceil((windowWRPX -
                        (windowWRPX / innerAspectRadio)) / 2);
                        that.cutW = windowWRPX - 200;
                        that.cutH = (windowWRPX / innerAspectRadio) - 200;
                        that.cutL = Math.ceil(((windowWRPX - windowWRPX) + 200) / 2);
                        that.cutT = Math.ceil(((windowWRPX / innerAspectRadio) -
                        ((windowWRPX / innerAspectRadio) - 200)) / 2);
                        that.scaleP = (res.width * pixelRatio) / windowWRPX;
                        that.imageW = res.width * pixelRatio;
                        that.imageH = res.height * pixelRatio;
                        that.innerAspectRadio = innerAspectRadio;
                    } else {
                        that.cropperW = windowWRPX * innerAspectRadio;
                        that.cropperH = windowWRPX;
                        that.cropperL = Math.ceil((windowWRPX -
                        (windowWRPX * innerAspectRadio)) / 2);
                        that.cropperT = Math.ceil((windowWRPX - windowWRPX) / 2);
                        that.cutW = (windowWRPX * innerAspectRadio) - 50;
                        that.cutH = 200;
                        that.cutL = Math.ceil(((windowWRPX * innerAspectRadio) -
                        ((windowWRPX * innerAspectRadio) - 50)) / 2);
                        that.cutT = Math.ceil((windowWRPX - 200) / 2);
                        that.scaleP = (res.width * pixelRatio) / windowWRPX;
                        that.imageW = res.width * pixelRatio;
                        that.imageH = res.height * pixelRatio;
                        that.innerAspectRadio = innerAspectRadio;
                    }
                    that.isShowImg = true;

                    that.$apply();
                    wx.hideLoading();
                },
            });
        },
    }

    loadImage() {
        const that = this;
        wx.showLoading({
            title: '图片加载中...',
        });

        ctx.drawImage(
            that.imageSrc,
            0,
            0,
            qualityWidth,
            qualityWidth / innerAspectRadio,
        );
        ctx.draw();

        wx.getImageInfo({
            src: that.imageSrc,
            success(res) {
                innerAspectRadio = res.width / res.height;
                // 根据图片的宽高显示不同的效果   保证图片可以正常显示
                if (innerAspectRadio >= 1) {
                    that.cropperW = windowWRPX;
                    that.cropperH = windowWRPX / innerAspectRadio;
                    that.cropperL = Math.ceil((windowWRPX - windowWRPX) / 2);
                    that.cropperT = Math.ceil((windowWRPX -
                    (windowWRPX / innerAspectRadio)) / 2);
                    that.cutW = windowWRPX - 200;
                    that.cutH = (windowWRPX / innerAspectRadio) - 200;
                    that.cutL = Math.ceil(((windowWRPX - windowWRPX) + 200) / 2);
                    that.cutT = Math.ceil(((windowWRPX / innerAspectRadio) -
                    ((windowWRPX / innerAspectRadio) - 200)) / 2);
                    that.scaleP = (res.width * pixelRatio) / windowWRPX;
                    that.imageW = res.width * pixelRatio;
                    that.imageH = res.height * pixelRatio;
                    that.innerAspectRadio = innerAspectRadio;
                } else {
                    that.cropperW = windowWRPX * innerAspectRadio;
                    that.cropperH = windowWRPX;
                    that.cropperL = Math.ceil((windowWRPX -
                    (windowWRPX * innerAspectRadio)) / 2);
                    that.cropperT = Math.ceil((windowWRPX - windowWRPX) / 2);
                    that.cutW = (windowWRPX * innerAspectRadio) - 50;
                    that.cutH = 200;
                    that.cutL = Math.ceil(((windowWRPX * innerAspectRadio) -
                    ((windowWRPX * innerAspectRadio) - 50)) / 2);
                    that.cutT = Math.ceil((windowWRPX - 200) / 2);
                    that.scaleP = (res.width * pixelRatio) / windowWRPX;
                    that.imageW = res.width * pixelRatio;
                    that.imageH = res.height * pixelRatio;
                    that.innerAspectRadio = innerAspectRadio;
                }
                that.isShowImg = true;

                that.$apply();
                wx.hideLoading();
            },
        });
    }

    methods = {
        getImage() {
            const that = this;
            wx.chooseImage({
                success(res) {
                    [that.imageSrc] = res.tempFilePaths;
                    that.$apply();
                    that.loadImage();
                },
            });
        },

        // 拖动时候触发的touchStart事件
        contentStartMove(e) {
            [{ pageX, pageY }] = e.touches;
        },

        // 拖动时候触发的touchMove事件
        contentMoveing(e) {
            const dragLengthX = (pageX - e.touches[0].pageX) * dragScaleP;
            const dragLengthY = (pageY - e.touches[0].pageY) * dragScaleP;
            const minX = Math.max(this.cutL - dragLengthX, 0);
            const minY = Math.max(this.cutT - dragLengthY, 0);
            const maxX = this.cropperW - this.cutW;
            const maxY = this.cropperH - this.cutH;
            this.cutL = Math.min(maxX, minX);
            this.cutT = Math.min(maxY, minY);
            this.$apply();
            // console.log(`${maxX} ----- ${minX}`);
            [{ pageX, pageY }] = e.touches;
        },

        // 设置大小的时候触发的touchStart事件
        dragStart(e) {
            sizeConfPageX = e.touches[0].pageX;
            sizeConfPageY = e.touches[0].pageY;
            initDragCutW = this.cutW;
            initDragCutL = this.cutL;
            initDragCutT = this.cutT;
            initDragCutH = this.cutH;
        },

        // 设置大小的时候触发的touchMove事件
        dragMove(e) {
            const that = this;
            const dragType = e.target.dataset.drag;
            let dragLength;
            switch (dragType) {
                case 'right':
                    dragLength =
                        (sizeConfPageX - e.touches[0].pageX) * dragScaleP;
                    if (initDragCutW >= dragLength) {
                        // 如果 移动小于0 说明是在往下啦  放大裁剪的高度  这样一来 图片的高度  最大 等于 图片的top值加 当前图片的高度  否则就说明超出界限
                        if (
                            dragLength < 0 &&
                            that.cropperW > initDragCutL + that.cutW
                        ) {
                            this.cutW = initDragCutW - dragLength;
                        }
                        // 如果是移动 大于0  说明在缩小  只需要缩小的距离小于原本裁剪的高度就ok
                        if (dragLength > 0) {
                            this.cutW = initDragCutW - dragLength;
                        } else {
                            return;
                        }

                        this.$apply();
                    }
                    break;
                case 'left':
                    dragLength =
                        (dragLength = sizeConfPageX - e.touches[0].pageX) *
                        dragScaleP;
                    // console.log(dragLength);
                    if (initDragCutW >= dragLength && initDragCutL > dragLength) {
                        if (dragLength < 0 && Math.abs(dragLength) >= initDragCutW) {
                            return;
                        }
                        this.cutL = initDragCutL - dragLength;
                        this.cutW = initDragCutW + dragLength;
                        this.$apply();
                    }
                    break;
                case 'top':
                    dragLength =
                        (sizeConfPageY - e.touches[0].pageY) * dragScaleP;
                    if (initDragCutH >= dragLength && initDragCutT > dragLength) {
                        if (dragLength < 0 && Math.abs(dragLength) >= initDragCutH) {
                            return;
                        }
                        this.cutT = initDragCutT - dragLength;
                        this.cutH = initDragCutH + dragLength;
                        this.$apply();
                    }
                    break;
                case 'bottom':
                    dragLength =
                        (sizeConfPageY - e.touches[0].pageY) * dragScaleP;
                    // console.log(dragLength);
                    // console.log(initDragCutH >= dragLength);
                    // console.log(that.cropperH > initDragCutT + that.cutH);
                    // 必须是 dragLength 向上缩小的时候必须小于原本的高度
                    if (initDragCutH >= dragLength) {
                        // 如果 移动小于0 说明是在往下啦  放大裁剪的高度  这样一来 图片的高度  最大 等于 图片的top值加 当前图片的高度  否则就说明超出界限
                        if (
                            dragLength < 0 &&
                            that.cropperH > initDragCutT + that.cutH
                        ) {
                            this.cutH = initDragCutH - dragLength;
                        }
                        // 如果是移动 大于0  说明在缩小  只需要缩小的距离小于原本裁剪的高度就ok
                        if (dragLength > 0) {
                            this.cutH = initDragCutH - dragLength;
                        } else {
                            return;
                        }

                        this.$apply();
                    }
                    break;
                case 'rightBottom': {
                    const dragLengthX =
                        (sizeConfPageX - e.touches[0].pageX) * dragScaleP;
                    const dragLengthY =
                        (sizeConfPageY - e.touches[0].pageY) * dragScaleP;
                    if (
                        initDragCutH >= dragLengthY &&
                        initDragCutW >= dragLengthX
                    ) {
                        // bottom 方向的变化
                        if (
                            (dragLengthY < 0 &&
                                that.cropperH >
                                    initDragCutT + that.cutH) ||
                            dragLengthY > 0
                        ) {
                            this.cutH = initDragCutH - dragLengthY;
                        }

                        // right 方向的变化
                        if (
                            (dragLengthX < 0 &&
                                that.cropperW >
                                    initDragCutL + that.cutW) ||
                            dragLengthX > 0
                        ) {
                            this.cutW = initDragCutW - dragLengthX;
                        } else {
                            return;
                        }

                        this.$apply();
                    }
                    break;
                }
                default:
                    break;
            }
        },

        rotateImage() {
            const that = this;
            const x = qualityWidth / 2;
            const y = (qualityWidth / innerAspectRadio) / 2;

            ctx.save();
            // 旋转坐标系，仅适用于每次旋转90度
            ctx.translate(x, y);
            // 以坐标系原点为圆心旋转
            ctx.rotate((90 * Math.PI) / 180);
            ctx.translate(-x, -y);
            ctx.drawImage(
                that.imageSrc,
                0,
                0,
                qualityWidth,
                qualityWidth / innerAspectRadio,
            );
            ctx.draw(false, () => {
                wx.canvasToTempFilePath({
                    x: 0,
                    y: 0,
                    destWidth: qualityWidth,
                    destHeight: qualityWidth / innerAspectRadio,
                    quality: 0.5,
                    canvasId: 'myCanvas',
                    success(res) {
                        wx.hideLoading();
                        // 成功获得地址的地方
                        // console.log(res.tempFilePath);
                        console.log(res.tempFilePath);
                        that.imageSrc = res.tempFilePath;
                        that.$apply();
                    },
                });
            });
        },

        // 获取图片
        getImageInfo() {
            const that = this;

            wx.showLoading({
                title: '图片生成中...',
            });
            ctx.draw(true, () => {
                // 获取画布要裁剪的位置和宽度   均为百分比 * 画布中图片的宽度    保证了在微信小程序中裁剪的图片模糊
                // 位置不对的问题 canvasT = (that.cutT / that.cropperH) * (that.imageH / pixelRatio)
                const canvasW = (that.cutW / that.cropperW) * qualityWidth;
                const canvasH = ((that.cutH / that.cropperH) * qualityWidth) / innerAspectRadio;
                const canvasL = (that.cutL / that.cropperW) * qualityWidth;
                const canvasT = ((that.cutT / that.cropperH) * qualityWidth) / innerAspectRadio;
                // console.log(`canvasW:${canvasW} --- canvasH: ${canvasH} --- canvasL:
                // ${canvasL} --- canvasT: ${canvasT} -------- that.imageW: ${
                //     that.imageW
                // }  ------- that.imageH: ${
                //     that.imageH
                // } ---- pixelRatio ${pixelRatio}`);
                wx.canvasToTempFilePath({
                    x: canvasL,
                    y: canvasT,
                    width: canvasW,
                    height: canvasH,
                    destWidth: canvasW,
                    destHeight: canvasH,
                    quality: 0.5,
                    canvasId: 'myCanvas',
                    success(res) {
                        wx.hideLoading();
                        // 成功获得地址的地方
                        // console.log(res.tempFilePath);
                        console.log('裁剪结果');
                        console.log(res.tempFilePath);
                        wx.previewImage({
                            current: '', // 当前显示图片的http链接
                            urls: [res.tempFilePath], // 需要预览的图片http链接列表
                        });
                    },
                });
            });
        },
    }
}
</script>

<style lang="scss">
/* pages/wx-cropper/index.wxss */
.wx-content-info {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background-color: #000;
}

.wx-corpper {
    position: relative;
    overflow: hidden;
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;
    -webkit-tap-highlight-color: transparent;
    -webkit-touch-callout: none;
    box-sizing: border-box;
}

.wx-corpper-content {
    position: absolute;
    top: 0;
    right: 0;
    bottom: 0;
    left: 0;
}

.wx-corpper-content image {
    display: block;
    width: 100%;
    min-width: 0 !important;
    max-width: none !important;
    height: 100%;
    min-height: 0 !important;
    max-height: none !important;
    image-orientation: 0deg !important;
    margin: 0 auto;
}

/* 移动图片效果 */
.wx-cropper-drag-box {
    position: absolute;
    top: 0;
    right: 0;
    bottom: 0;
    left: 0;
    cursor: move;
    background: rgba(0, 0, 0, 0.6);
    z-index: 1;
}

/* 内部的信息 */
.wx-corpper-crop-box {
    position: absolute;
    width: 500rpx;
    height: 500rpx;
    background: rgba(255, 255, 255, 0.3);
    z-index: 2;
}

.wx-corpper-crop-box .wx-cropper-view-box {
    position: relative;
    display: block;
    width: 100%;
    height: 100%;
    overflow: visible;
    outline: 1px solid #69f;
    outline-color: rgba(102, 153, 255, 0.75);
}

.crop-mask {
    box-sizing: border-box;
    width: 100%;
    height: 100%;
    position: absolute;
    top: 0;
    left: 0;
    border-top: 50rpx;
    border-right: 80rpx;
    border-bottom: 100rpx;
    border-left: 120rpx;
    border-style: solid;
    border-color: rgba(0, 0, 0, 0.8);
}

/* 横向虚线 */
.wx-cropper-dashed-h {
    position: absolute;
    top: 33.33333333%;
    left: 0;
    width: 100%;
    height: 33.33333333%;
    border-top: 1px dashed rgba(255, 255, 255, 0.5);
    border-bottom: 1px dashed rgba(255, 255, 255, 0.5);
}

/* 纵向虚线 */
.wx-cropper-dashed-v {
    position: absolute;
    left: 33.33333333%;
    top: 0;
    width: 33.33333333%;
    height: 100%;
    border-left: 1px dashed rgba(255, 255, 255, 0.5);
    border-right: 1px dashed rgba(255, 255, 255, 0.5);
}

/* 四个方向的线  为了之后的拖动事件*/
.wx-cropper-line-t {
    position: absolute;
    display: block;
    width: 100%;
    background-color: #69f;
    top: 0;
    left: 0;
    height: 1px;
    opacity: 0.1;
    cursor: n-resize;
}

.wx-cropper-line-t::before {
    content: '';
    position: absolute;
    top: 50%;
    right: 0rpx;
    width: 100%;
    -webkit-transform: translate3d(0, -50%, 0);
    transform: translate3d(0, -50%, 0);
    bottom: 0;
    height: 41rpx;
    background: transparent;
    z-index: 11;
}

.wx-cropper-line-r {
    position: absolute;
    display: block;
    background-color: #69f;
    top: 0;
    right: 0px;
    width: 1px;
    opacity: 0.1;
    height: 100%;
    cursor: e-resize;
}
.wx-cropper-line-r::before {
    content: '';
    position: absolute;
    top: 0;
    left: 50%;
    width: 41rpx;
    -webkit-transform: translate3d(-50%, 0, 0);
    transform: translate3d(-50%, 0, 0);
    bottom: 0;
    height: 100%;
    background: transparent;
    z-index: 11;
}

.wx-cropper-line-b {
    position: absolute;
    display: block;
    width: 100%;
    background-color: #69f;
    bottom: 0;
    left: 0;
    height: 1px;
    opacity: 0.1;
    cursor: s-resize;
}

.wx-cropper-line-b::before {
    content: '';
    position: absolute;
    top: 50%;
    right: 0rpx;
    width: 100%;
    -webkit-transform: translate3d(0, -50%, 0);
    transform: translate3d(0, -50%, 0);
    bottom: 0;
    height: 41rpx;
    background: transparent;
    z-index: 11;
}

.wx-cropper-line-l {
    position: absolute;
    display: block;
    background-color: #69f;
    top: 0;
    left: 0;
    width: 1px;
    opacity: 0.1;
    height: 100%;
    cursor: w-resize;
}
.wx-cropper-line-l::before {
    content: '';
    position: absolute;
    top: 0;
    left: 50%;
    width: 41rpx;
    -webkit-transform: translate3d(-50%, 0, 0);
    transform: translate3d(-50%, 0, 0);
    bottom: 0;
    height: 100%;
    background: transparent;
    z-index: 11;
}

.wx-cropper-point {
    width: 5px;
    height: 5px;
    background-color: #69f;
    opacity: 0.75;
    position: absolute;
    z-index: 3;
}

.point-t {
    top: -3px;
    left: 50%;
    margin-left: -3px;
    cursor: n-resize;
}

.point-tr {
    top: -3px;
    left: 100%;
    margin-left: -3px;
    cursor: n-resize;
}

.point-r {
    top: 50%;
    left: 100%;
    margin-left: -3px;
    margin-top: -3px;
    cursor: n-resize;
}

.point-rb {
    left: 100%;
    top: 100%;
    -webkit-transform: translate3d(-50%, -50%, 0);
    transform: translate3d(-50%, -50%, 0);
    cursor: n-resize;
    width: 24rpx;
    height: 24rpx;
    background-color: #69f;
    position: absolute;
    z-index: 1112;
    opacity: 1;
}

.point-b {
    left: 50%;
    top: 100%;
    margin-left: -3px;
    margin-top: -3px;
    cursor: n-resize;
}

.point-bl {
    left: 0%;
    top: 100%;
    margin-left: -3px;
    margin-top: -3px;
    cursor: n-resize;
}

.point-l {
    left: 0%;
    top: 50%;
    margin-left: -3px;
    margin-top: -3px;
    cursor: n-resize;
}

.point-lt {
    left: 0%;
    top: 0%;
    margin-left: -3px;
    margin-top: -3px;
    cursor: n-resize;
}

/* 裁剪框预览内容 */
.wx-cropper-viewer {
    position: relative;
    width: 100%;
    height: 100%;
    overflow: hidden;
}

.wx-cropper-viewer image {
    position: absolute;
    z-index: 2;
}

.picker {
    width: 300rpx;
}

.options {
    .option-item {
        color: #fff;
        font-size: 34rpx;
        line-height: 48rpx;
        position: fixed;
    }

    .restore,.rotate {
        bottom: 128rpx;
    }
    .restore {
        left: 250rpx;
        &::before {
            content: '';
            display: block;
            position: absolute;
            left: -40rpx;
            top: 9rpx;
            width: 30rpx;
            height: 30rpx;
            background-image: url('/crop-restore.png');
            background-size: 30rpx 30rpx;
        }
    }
    .rotate {
        right: 210rpx;
        &::before {
            content: '';
            display: block;
            position: absolute;
            left: -40rpx;
            top: 9rpx;
            width: 30rpx;
            height: 30rpx;
            background-image: url('/crop-rotate.png');
            background-size: 30rpx 30rpx;
        }
    }

    .cancel,.crop {
        bottom: 40rpx;
    }
    .cancel {
        left: 40rpx;
    }
    .crop {
        right: 40rpx;
    }
}
</style>
